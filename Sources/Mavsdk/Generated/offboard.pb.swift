// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: offboard.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Mavsdk_Rpc_Offboard_StartRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Offboard_StartResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offboardResult: Mavsdk_Rpc_Offboard_OffboardResult {
    get {return _offboardResult ?? Mavsdk_Rpc_Offboard_OffboardResult()}
    set {_offboardResult = newValue}
  }
  /// Returns true if `offboardResult` has been explicitly set.
  var hasOffboardResult: Bool {return self._offboardResult != nil}
  /// Clears the value of `offboardResult`. Subsequent reads from it will return its default value.
  mutating func clearOffboardResult() {self._offboardResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _offboardResult: Mavsdk_Rpc_Offboard_OffboardResult? = nil
}

struct Mavsdk_Rpc_Offboard_StopRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Offboard_StopResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offboardResult: Mavsdk_Rpc_Offboard_OffboardResult {
    get {return _offboardResult ?? Mavsdk_Rpc_Offboard_OffboardResult()}
    set {_offboardResult = newValue}
  }
  /// Returns true if `offboardResult` has been explicitly set.
  var hasOffboardResult: Bool {return self._offboardResult != nil}
  /// Clears the value of `offboardResult`. Subsequent reads from it will return its default value.
  mutating func clearOffboardResult() {self._offboardResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _offboardResult: Mavsdk_Rpc_Offboard_OffboardResult? = nil
}

struct Mavsdk_Rpc_Offboard_IsActiveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Offboard_IsActiveResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// True if offboard is active
  var isActive: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_Offboard_SetAttitudeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Attitude roll, pitch and yaw along with thrust
  var attitude: Mavsdk_Rpc_Offboard_Attitude {
    get {return _attitude ?? Mavsdk_Rpc_Offboard_Attitude()}
    set {_attitude = newValue}
  }
  /// Returns true if `attitude` has been explicitly set.
  var hasAttitude: Bool {return self._attitude != nil}
  /// Clears the value of `attitude`. Subsequent reads from it will return its default value.
  mutating func clearAttitude() {self._attitude = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _attitude: Mavsdk_Rpc_Offboard_Attitude? = nil
}

struct Mavsdk_Rpc_Offboard_SetAttitudeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offboardResult: Mavsdk_Rpc_Offboard_OffboardResult {
    get {return _offboardResult ?? Mavsdk_Rpc_Offboard_OffboardResult()}
    set {_offboardResult = newValue}
  }
  /// Returns true if `offboardResult` has been explicitly set.
  var hasOffboardResult: Bool {return self._offboardResult != nil}
  /// Clears the value of `offboardResult`. Subsequent reads from it will return its default value.
  mutating func clearOffboardResult() {self._offboardResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _offboardResult: Mavsdk_Rpc_Offboard_OffboardResult? = nil
}

struct Mavsdk_Rpc_Offboard_SetActuatorControlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Actuator control values
  var actuatorControl: Mavsdk_Rpc_Offboard_ActuatorControl {
    get {return _actuatorControl ?? Mavsdk_Rpc_Offboard_ActuatorControl()}
    set {_actuatorControl = newValue}
  }
  /// Returns true if `actuatorControl` has been explicitly set.
  var hasActuatorControl: Bool {return self._actuatorControl != nil}
  /// Clears the value of `actuatorControl`. Subsequent reads from it will return its default value.
  mutating func clearActuatorControl() {self._actuatorControl = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _actuatorControl: Mavsdk_Rpc_Offboard_ActuatorControl? = nil
}

struct Mavsdk_Rpc_Offboard_SetActuatorControlResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offboardResult: Mavsdk_Rpc_Offboard_OffboardResult {
    get {return _offboardResult ?? Mavsdk_Rpc_Offboard_OffboardResult()}
    set {_offboardResult = newValue}
  }
  /// Returns true if `offboardResult` has been explicitly set.
  var hasOffboardResult: Bool {return self._offboardResult != nil}
  /// Clears the value of `offboardResult`. Subsequent reads from it will return its default value.
  mutating func clearOffboardResult() {self._offboardResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _offboardResult: Mavsdk_Rpc_Offboard_OffboardResult? = nil
}

struct Mavsdk_Rpc_Offboard_SetAttitudeRateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Attitude rate roll, pitch and yaw angular rate along with thrust
  var attitudeRate: Mavsdk_Rpc_Offboard_AttitudeRate {
    get {return _attitudeRate ?? Mavsdk_Rpc_Offboard_AttitudeRate()}
    set {_attitudeRate = newValue}
  }
  /// Returns true if `attitudeRate` has been explicitly set.
  var hasAttitudeRate: Bool {return self._attitudeRate != nil}
  /// Clears the value of `attitudeRate`. Subsequent reads from it will return its default value.
  mutating func clearAttitudeRate() {self._attitudeRate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _attitudeRate: Mavsdk_Rpc_Offboard_AttitudeRate? = nil
}

struct Mavsdk_Rpc_Offboard_SetAttitudeRateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offboardResult: Mavsdk_Rpc_Offboard_OffboardResult {
    get {return _offboardResult ?? Mavsdk_Rpc_Offboard_OffboardResult()}
    set {_offboardResult = newValue}
  }
  /// Returns true if `offboardResult` has been explicitly set.
  var hasOffboardResult: Bool {return self._offboardResult != nil}
  /// Clears the value of `offboardResult`. Subsequent reads from it will return its default value.
  mutating func clearOffboardResult() {self._offboardResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _offboardResult: Mavsdk_Rpc_Offboard_OffboardResult? = nil
}

struct Mavsdk_Rpc_Offboard_SetPositionNedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Position and yaw
  var positionNedYaw: Mavsdk_Rpc_Offboard_PositionNedYaw {
    get {return _positionNedYaw ?? Mavsdk_Rpc_Offboard_PositionNedYaw()}
    set {_positionNedYaw = newValue}
  }
  /// Returns true if `positionNedYaw` has been explicitly set.
  var hasPositionNedYaw: Bool {return self._positionNedYaw != nil}
  /// Clears the value of `positionNedYaw`. Subsequent reads from it will return its default value.
  mutating func clearPositionNedYaw() {self._positionNedYaw = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _positionNedYaw: Mavsdk_Rpc_Offboard_PositionNedYaw? = nil
}

struct Mavsdk_Rpc_Offboard_SetPositionNedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offboardResult: Mavsdk_Rpc_Offboard_OffboardResult {
    get {return _offboardResult ?? Mavsdk_Rpc_Offboard_OffboardResult()}
    set {_offboardResult = newValue}
  }
  /// Returns true if `offboardResult` has been explicitly set.
  var hasOffboardResult: Bool {return self._offboardResult != nil}
  /// Clears the value of `offboardResult`. Subsequent reads from it will return its default value.
  mutating func clearOffboardResult() {self._offboardResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _offboardResult: Mavsdk_Rpc_Offboard_OffboardResult? = nil
}

struct Mavsdk_Rpc_Offboard_SetVelocityBodyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Velocity and yaw angular rate
  var velocityBodyYawspeed: Mavsdk_Rpc_Offboard_VelocityBodyYawspeed {
    get {return _velocityBodyYawspeed ?? Mavsdk_Rpc_Offboard_VelocityBodyYawspeed()}
    set {_velocityBodyYawspeed = newValue}
  }
  /// Returns true if `velocityBodyYawspeed` has been explicitly set.
  var hasVelocityBodyYawspeed: Bool {return self._velocityBodyYawspeed != nil}
  /// Clears the value of `velocityBodyYawspeed`. Subsequent reads from it will return its default value.
  mutating func clearVelocityBodyYawspeed() {self._velocityBodyYawspeed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _velocityBodyYawspeed: Mavsdk_Rpc_Offboard_VelocityBodyYawspeed? = nil
}

struct Mavsdk_Rpc_Offboard_SetVelocityBodyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offboardResult: Mavsdk_Rpc_Offboard_OffboardResult {
    get {return _offboardResult ?? Mavsdk_Rpc_Offboard_OffboardResult()}
    set {_offboardResult = newValue}
  }
  /// Returns true if `offboardResult` has been explicitly set.
  var hasOffboardResult: Bool {return self._offboardResult != nil}
  /// Clears the value of `offboardResult`. Subsequent reads from it will return its default value.
  mutating func clearOffboardResult() {self._offboardResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _offboardResult: Mavsdk_Rpc_Offboard_OffboardResult? = nil
}

struct Mavsdk_Rpc_Offboard_SetVelocityNedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Velocity and yaw
  var velocityNedYaw: Mavsdk_Rpc_Offboard_VelocityNedYaw {
    get {return _velocityNedYaw ?? Mavsdk_Rpc_Offboard_VelocityNedYaw()}
    set {_velocityNedYaw = newValue}
  }
  /// Returns true if `velocityNedYaw` has been explicitly set.
  var hasVelocityNedYaw: Bool {return self._velocityNedYaw != nil}
  /// Clears the value of `velocityNedYaw`. Subsequent reads from it will return its default value.
  mutating func clearVelocityNedYaw() {self._velocityNedYaw = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _velocityNedYaw: Mavsdk_Rpc_Offboard_VelocityNedYaw? = nil
}

struct Mavsdk_Rpc_Offboard_SetVelocityNedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offboardResult: Mavsdk_Rpc_Offboard_OffboardResult {
    get {return _offboardResult ?? Mavsdk_Rpc_Offboard_OffboardResult()}
    set {_offboardResult = newValue}
  }
  /// Returns true if `offboardResult` has been explicitly set.
  var hasOffboardResult: Bool {return self._offboardResult != nil}
  /// Clears the value of `offboardResult`. Subsequent reads from it will return its default value.
  mutating func clearOffboardResult() {self._offboardResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _offboardResult: Mavsdk_Rpc_Offboard_OffboardResult? = nil
}

struct Mavsdk_Rpc_Offboard_SetPositionVelocityNedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Position and yaw
  var positionNedYaw: Mavsdk_Rpc_Offboard_PositionNedYaw {
    get {return _positionNedYaw ?? Mavsdk_Rpc_Offboard_PositionNedYaw()}
    set {_positionNedYaw = newValue}
  }
  /// Returns true if `positionNedYaw` has been explicitly set.
  var hasPositionNedYaw: Bool {return self._positionNedYaw != nil}
  /// Clears the value of `positionNedYaw`. Subsequent reads from it will return its default value.
  mutating func clearPositionNedYaw() {self._positionNedYaw = nil}

  /// Velocity and yaw
  var velocityNedYaw: Mavsdk_Rpc_Offboard_VelocityNedYaw {
    get {return _velocityNedYaw ?? Mavsdk_Rpc_Offboard_VelocityNedYaw()}
    set {_velocityNedYaw = newValue}
  }
  /// Returns true if `velocityNedYaw` has been explicitly set.
  var hasVelocityNedYaw: Bool {return self._velocityNedYaw != nil}
  /// Clears the value of `velocityNedYaw`. Subsequent reads from it will return its default value.
  mutating func clearVelocityNedYaw() {self._velocityNedYaw = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _positionNedYaw: Mavsdk_Rpc_Offboard_PositionNedYaw? = nil
  fileprivate var _velocityNedYaw: Mavsdk_Rpc_Offboard_VelocityNedYaw? = nil
}

struct Mavsdk_Rpc_Offboard_SetPositionVelocityNedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offboardResult: Mavsdk_Rpc_Offboard_OffboardResult {
    get {return _offboardResult ?? Mavsdk_Rpc_Offboard_OffboardResult()}
    set {_offboardResult = newValue}
  }
  /// Returns true if `offboardResult` has been explicitly set.
  var hasOffboardResult: Bool {return self._offboardResult != nil}
  /// Clears the value of `offboardResult`. Subsequent reads from it will return its default value.
  mutating func clearOffboardResult() {self._offboardResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _offboardResult: Mavsdk_Rpc_Offboard_OffboardResult? = nil
}

struct Mavsdk_Rpc_Offboard_SetAccelerationNedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Acceleration
  var accelerationNed: Mavsdk_Rpc_Offboard_AccelerationNed {
    get {return _accelerationNed ?? Mavsdk_Rpc_Offboard_AccelerationNed()}
    set {_accelerationNed = newValue}
  }
  /// Returns true if `accelerationNed` has been explicitly set.
  var hasAccelerationNed: Bool {return self._accelerationNed != nil}
  /// Clears the value of `accelerationNed`. Subsequent reads from it will return its default value.
  mutating func clearAccelerationNed() {self._accelerationNed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accelerationNed: Mavsdk_Rpc_Offboard_AccelerationNed? = nil
}

struct Mavsdk_Rpc_Offboard_SetAccelerationNedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offboardResult: Mavsdk_Rpc_Offboard_OffboardResult {
    get {return _offboardResult ?? Mavsdk_Rpc_Offboard_OffboardResult()}
    set {_offboardResult = newValue}
  }
  /// Returns true if `offboardResult` has been explicitly set.
  var hasOffboardResult: Bool {return self._offboardResult != nil}
  /// Clears the value of `offboardResult`. Subsequent reads from it will return its default value.
  mutating func clearOffboardResult() {self._offboardResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _offboardResult: Mavsdk_Rpc_Offboard_OffboardResult? = nil
}

/// Type for attitude body angles in NED reference frame (roll, pitch, yaw and thrust)
struct Mavsdk_Rpc_Offboard_Attitude {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Roll angle (in degrees, positive is right side down)
  var rollDeg: Float = 0

  /// Pitch angle (in degrees, positive is nose up)
  var pitchDeg: Float = 0

  /// Yaw angle (in degrees, positive is move nose to the right)
  var yawDeg: Float = 0

  /// Thrust (range: 0 to 1)
  var thrustValue: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Eight controls that will be given to the group. Each control is a normalized
/// (-1..+1) command value, which will be mapped and scaled through the mixer.
struct Mavsdk_Rpc_Offboard_ActuatorControlGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Controls in the group
  var controls: [Float] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Type for actuator control.
///
/// Control members should be normed to -1..+1 where 0 is neutral position.
/// Throttle for single rotation direction motors is 0..1, negative range for reverse direction.
///
/// One group support eight controls.
///
/// Up to 16 actuator controls can be set. To ignore an output group, set all it conrols to NaN.
/// If one or more controls in group is not NaN, then all NaN controls will sent as zero.
/// The first 8 actuator controls internally map to control group 0, the latter 8 actuator
/// controls map to control group 1. Depending on what controls are set (instead of NaN) 1 or 2
/// MAVLink messages are actually sent.
///
/// In PX4 v1.9.0 Only first four Control Groups are supported
/// (https://github.com/PX4/Firmware/blob/v1.9.0/src/modules/mavlink/mavlink_receiver.cpp#L980).
struct Mavsdk_Rpc_Offboard_ActuatorControl {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Control groups.
  var groups: [Mavsdk_Rpc_Offboard_ActuatorControlGroup] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Type for attitude rate commands in body coordinates (roll, pitch, yaw angular rate and thrust)
struct Mavsdk_Rpc_Offboard_AttitudeRate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Roll angular rate (in degrees/second, positive for clock-wise looking from front)
  var rollDegS: Float = 0

  /// Pitch angular rate (in degrees/second, positive for head/front moving up)
  var pitchDegS: Float = 0

  /// Yaw angular rate (in degrees/second, positive for clock-wise looking from above)
  var yawDegS: Float = 0

  /// Thrust (range: 0 to 1)
  var thrustValue: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Type for position commands in NED (North East Down) coordinates and yaw.
struct Mavsdk_Rpc_Offboard_PositionNedYaw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Position North (in metres)
  var northM: Float = 0

  /// Position East (in metres)
  var eastM: Float = 0

  /// Position Down (in metres)
  var downM: Float = 0

  /// Yaw in degrees (0 North, positive is clock-wise looking from above)
  var yawDeg: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Type for velocity commands in body coordinates.
struct Mavsdk_Rpc_Offboard_VelocityBodyYawspeed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Velocity forward (in metres/second)
  var forwardMS: Float = 0

  /// Velocity right (in metres/second)
  var rightMS: Float = 0

  /// Velocity down (in metres/second)
  var downMS: Float = 0

  /// Yaw angular rate (in degrees/second, positive for clock-wise looking from above)
  var yawspeedDegS: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Type for velocity commands in NED (North East Down) coordinates and yaw.
struct Mavsdk_Rpc_Offboard_VelocityNedYaw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Velocity North (in metres/second)
  var northMS: Float = 0

  /// Velocity East (in metres/second)
  var eastMS: Float = 0

  /// Velocity Down (in metres/second)
  var downMS: Float = 0

  /// Yaw in degrees (0 North, positive is clock-wise looking from above)
  var yawDeg: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Type for acceleration commands in NED (North East Down) coordinates.
struct Mavsdk_Rpc_Offboard_AccelerationNed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Acceleration North (in metres/second^2)
  var northMS2: Float = 0

  /// Acceleration East (in metres/second^2)
  var eastMS2: Float = 0

  /// Acceleration Down (in metres/second^2)
  var downMS2: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result type.
struct Mavsdk_Rpc_Offboard_OffboardResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Result enum value
  var result: Mavsdk_Rpc_Offboard_OffboardResult.Result = .unknown

  /// Human-readable English string describing the result
  var resultStr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible results returned for offboard requests
  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unknown result
    case unknown // = 0

    /// Request succeeded
    case success // = 1

    /// No system is connected
    case noSystem // = 2

    /// Connection error
    case connectionError // = 3

    /// Vehicle is busy
    case busy // = 4

    /// Command denied
    case commandDenied // = 5

    /// Request timed out
    case timeout // = 6

    /// Cannot start without setpoint set
    case noSetpointSet // = 7
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .success
      case 2: self = .noSystem
      case 3: self = .connectionError
      case 4: self = .busy
      case 5: self = .commandDenied
      case 6: self = .timeout
      case 7: self = .noSetpointSet
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .success: return 1
      case .noSystem: return 2
      case .connectionError: return 3
      case .busy: return 4
      case .commandDenied: return 5
      case .timeout: return 6
      case .noSetpointSet: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Mavsdk_Rpc_Offboard_OffboardResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mavsdk_Rpc_Offboard_OffboardResult.Result] = [
    .unknown,
    .success,
    .noSystem,
    .connectionError,
    .busy,
    .commandDenied,
    .timeout,
    .noSetpointSet,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mavsdk.rpc.offboard"

extension Mavsdk_Rpc_Offboard_StartRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_StartRequest, rhs: Mavsdk_Rpc_Offboard_StartRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_StartResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offboard_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._offboardResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._offboardResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_StartResponse, rhs: Mavsdk_Rpc_Offboard_StartResponse) -> Bool {
    if lhs._offboardResult != rhs._offboardResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_StopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_StopRequest, rhs: Mavsdk_Rpc_Offboard_StopRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_StopResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offboard_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._offboardResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._offboardResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_StopResponse, rhs: Mavsdk_Rpc_Offboard_StopResponse) -> Bool {
    if lhs._offboardResult != rhs._offboardResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_IsActiveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsActiveRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_IsActiveRequest, rhs: Mavsdk_Rpc_Offboard_IsActiveRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_IsActiveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsActiveResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_active"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isActive) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isActive != false {
      try visitor.visitSingularBoolField(value: self.isActive, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_IsActiveResponse, rhs: Mavsdk_Rpc_Offboard_IsActiveResponse) -> Bool {
    if lhs.isActive != rhs.isActive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_SetAttitudeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetAttitudeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._attitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._attitude {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_SetAttitudeRequest, rhs: Mavsdk_Rpc_Offboard_SetAttitudeRequest) -> Bool {
    if lhs._attitude != rhs._attitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_SetAttitudeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetAttitudeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offboard_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._offboardResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._offboardResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_SetAttitudeResponse, rhs: Mavsdk_Rpc_Offboard_SetAttitudeResponse) -> Bool {
    if lhs._offboardResult != rhs._offboardResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_SetActuatorControlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetActuatorControlRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "actuator_control"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actuatorControl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._actuatorControl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_SetActuatorControlRequest, rhs: Mavsdk_Rpc_Offboard_SetActuatorControlRequest) -> Bool {
    if lhs._actuatorControl != rhs._actuatorControl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_SetActuatorControlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetActuatorControlResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offboard_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._offboardResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._offboardResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_SetActuatorControlResponse, rhs: Mavsdk_Rpc_Offboard_SetActuatorControlResponse) -> Bool {
    if lhs._offboardResult != rhs._offboardResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_SetAttitudeRateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetAttitudeRateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attitude_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._attitudeRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._attitudeRate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_SetAttitudeRateRequest, rhs: Mavsdk_Rpc_Offboard_SetAttitudeRateRequest) -> Bool {
    if lhs._attitudeRate != rhs._attitudeRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_SetAttitudeRateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetAttitudeRateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offboard_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._offboardResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._offboardResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_SetAttitudeRateResponse, rhs: Mavsdk_Rpc_Offboard_SetAttitudeRateResponse) -> Bool {
    if lhs._offboardResult != rhs._offboardResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_SetPositionNedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetPositionNedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "position_ned_yaw"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._positionNedYaw) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._positionNedYaw {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_SetPositionNedRequest, rhs: Mavsdk_Rpc_Offboard_SetPositionNedRequest) -> Bool {
    if lhs._positionNedYaw != rhs._positionNedYaw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_SetPositionNedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetPositionNedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offboard_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._offboardResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._offboardResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_SetPositionNedResponse, rhs: Mavsdk_Rpc_Offboard_SetPositionNedResponse) -> Bool {
    if lhs._offboardResult != rhs._offboardResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_SetVelocityBodyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetVelocityBodyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "velocity_body_yawspeed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._velocityBodyYawspeed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._velocityBodyYawspeed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_SetVelocityBodyRequest, rhs: Mavsdk_Rpc_Offboard_SetVelocityBodyRequest) -> Bool {
    if lhs._velocityBodyYawspeed != rhs._velocityBodyYawspeed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_SetVelocityBodyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetVelocityBodyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offboard_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._offboardResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._offboardResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_SetVelocityBodyResponse, rhs: Mavsdk_Rpc_Offboard_SetVelocityBodyResponse) -> Bool {
    if lhs._offboardResult != rhs._offboardResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_SetVelocityNedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetVelocityNedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "velocity_ned_yaw"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._velocityNedYaw) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._velocityNedYaw {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_SetVelocityNedRequest, rhs: Mavsdk_Rpc_Offboard_SetVelocityNedRequest) -> Bool {
    if lhs._velocityNedYaw != rhs._velocityNedYaw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_SetVelocityNedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetVelocityNedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offboard_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._offboardResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._offboardResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_SetVelocityNedResponse, rhs: Mavsdk_Rpc_Offboard_SetVelocityNedResponse) -> Bool {
    if lhs._offboardResult != rhs._offboardResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_SetPositionVelocityNedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetPositionVelocityNedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "position_ned_yaw"),
    2: .standard(proto: "velocity_ned_yaw"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._positionNedYaw) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._velocityNedYaw) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._positionNedYaw {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._velocityNedYaw {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_SetPositionVelocityNedRequest, rhs: Mavsdk_Rpc_Offboard_SetPositionVelocityNedRequest) -> Bool {
    if lhs._positionNedYaw != rhs._positionNedYaw {return false}
    if lhs._velocityNedYaw != rhs._velocityNedYaw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_SetPositionVelocityNedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetPositionVelocityNedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offboard_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._offboardResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._offboardResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_SetPositionVelocityNedResponse, rhs: Mavsdk_Rpc_Offboard_SetPositionVelocityNedResponse) -> Bool {
    if lhs._offboardResult != rhs._offboardResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_SetAccelerationNedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetAccelerationNedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "acceleration_ned"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accelerationNed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._accelerationNed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_SetAccelerationNedRequest, rhs: Mavsdk_Rpc_Offboard_SetAccelerationNedRequest) -> Bool {
    if lhs._accelerationNed != rhs._accelerationNed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_SetAccelerationNedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetAccelerationNedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offboard_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._offboardResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._offboardResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_SetAccelerationNedResponse, rhs: Mavsdk_Rpc_Offboard_SetAccelerationNedResponse) -> Bool {
    if lhs._offboardResult != rhs._offboardResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_Attitude: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Attitude"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "roll_deg"),
    2: .standard(proto: "pitch_deg"),
    3: .standard(proto: "yaw_deg"),
    4: .standard(proto: "thrust_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.rollDeg) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.pitchDeg) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.yawDeg) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.thrustValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rollDeg != 0 {
      try visitor.visitSingularFloatField(value: self.rollDeg, fieldNumber: 1)
    }
    if self.pitchDeg != 0 {
      try visitor.visitSingularFloatField(value: self.pitchDeg, fieldNumber: 2)
    }
    if self.yawDeg != 0 {
      try visitor.visitSingularFloatField(value: self.yawDeg, fieldNumber: 3)
    }
    if self.thrustValue != 0 {
      try visitor.visitSingularFloatField(value: self.thrustValue, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_Attitude, rhs: Mavsdk_Rpc_Offboard_Attitude) -> Bool {
    if lhs.rollDeg != rhs.rollDeg {return false}
    if lhs.pitchDeg != rhs.pitchDeg {return false}
    if lhs.yawDeg != rhs.yawDeg {return false}
    if lhs.thrustValue != rhs.thrustValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_ActuatorControlGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActuatorControlGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "controls"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.controls) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.controls.isEmpty {
      try visitor.visitPackedFloatField(value: self.controls, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_ActuatorControlGroup, rhs: Mavsdk_Rpc_Offboard_ActuatorControlGroup) -> Bool {
    if lhs.controls != rhs.controls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_ActuatorControl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActuatorControl"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_ActuatorControl, rhs: Mavsdk_Rpc_Offboard_ActuatorControl) -> Bool {
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_AttitudeRate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttitudeRate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "roll_deg_s"),
    2: .standard(proto: "pitch_deg_s"),
    3: .standard(proto: "yaw_deg_s"),
    4: .standard(proto: "thrust_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.rollDegS) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.pitchDegS) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.yawDegS) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.thrustValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rollDegS != 0 {
      try visitor.visitSingularFloatField(value: self.rollDegS, fieldNumber: 1)
    }
    if self.pitchDegS != 0 {
      try visitor.visitSingularFloatField(value: self.pitchDegS, fieldNumber: 2)
    }
    if self.yawDegS != 0 {
      try visitor.visitSingularFloatField(value: self.yawDegS, fieldNumber: 3)
    }
    if self.thrustValue != 0 {
      try visitor.visitSingularFloatField(value: self.thrustValue, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_AttitudeRate, rhs: Mavsdk_Rpc_Offboard_AttitudeRate) -> Bool {
    if lhs.rollDegS != rhs.rollDegS {return false}
    if lhs.pitchDegS != rhs.pitchDegS {return false}
    if lhs.yawDegS != rhs.yawDegS {return false}
    if lhs.thrustValue != rhs.thrustValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_PositionNedYaw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionNedYaw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "north_m"),
    2: .standard(proto: "east_m"),
    3: .standard(proto: "down_m"),
    4: .standard(proto: "yaw_deg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.northM) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.eastM) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.downM) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.yawDeg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.northM != 0 {
      try visitor.visitSingularFloatField(value: self.northM, fieldNumber: 1)
    }
    if self.eastM != 0 {
      try visitor.visitSingularFloatField(value: self.eastM, fieldNumber: 2)
    }
    if self.downM != 0 {
      try visitor.visitSingularFloatField(value: self.downM, fieldNumber: 3)
    }
    if self.yawDeg != 0 {
      try visitor.visitSingularFloatField(value: self.yawDeg, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_PositionNedYaw, rhs: Mavsdk_Rpc_Offboard_PositionNedYaw) -> Bool {
    if lhs.northM != rhs.northM {return false}
    if lhs.eastM != rhs.eastM {return false}
    if lhs.downM != rhs.downM {return false}
    if lhs.yawDeg != rhs.yawDeg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_VelocityBodyYawspeed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VelocityBodyYawspeed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "forward_m_s"),
    2: .standard(proto: "right_m_s"),
    3: .standard(proto: "down_m_s"),
    4: .standard(proto: "yawspeed_deg_s"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.forwardMS) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.rightMS) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.downMS) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.yawspeedDegS) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.forwardMS != 0 {
      try visitor.visitSingularFloatField(value: self.forwardMS, fieldNumber: 1)
    }
    if self.rightMS != 0 {
      try visitor.visitSingularFloatField(value: self.rightMS, fieldNumber: 2)
    }
    if self.downMS != 0 {
      try visitor.visitSingularFloatField(value: self.downMS, fieldNumber: 3)
    }
    if self.yawspeedDegS != 0 {
      try visitor.visitSingularFloatField(value: self.yawspeedDegS, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_VelocityBodyYawspeed, rhs: Mavsdk_Rpc_Offboard_VelocityBodyYawspeed) -> Bool {
    if lhs.forwardMS != rhs.forwardMS {return false}
    if lhs.rightMS != rhs.rightMS {return false}
    if lhs.downMS != rhs.downMS {return false}
    if lhs.yawspeedDegS != rhs.yawspeedDegS {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_VelocityNedYaw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VelocityNedYaw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "north_m_s"),
    2: .standard(proto: "east_m_s"),
    3: .standard(proto: "down_m_s"),
    4: .standard(proto: "yaw_deg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.northMS) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.eastMS) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.downMS) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.yawDeg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.northMS != 0 {
      try visitor.visitSingularFloatField(value: self.northMS, fieldNumber: 1)
    }
    if self.eastMS != 0 {
      try visitor.visitSingularFloatField(value: self.eastMS, fieldNumber: 2)
    }
    if self.downMS != 0 {
      try visitor.visitSingularFloatField(value: self.downMS, fieldNumber: 3)
    }
    if self.yawDeg != 0 {
      try visitor.visitSingularFloatField(value: self.yawDeg, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_VelocityNedYaw, rhs: Mavsdk_Rpc_Offboard_VelocityNedYaw) -> Bool {
    if lhs.northMS != rhs.northMS {return false}
    if lhs.eastMS != rhs.eastMS {return false}
    if lhs.downMS != rhs.downMS {return false}
    if lhs.yawDeg != rhs.yawDeg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_AccelerationNed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccelerationNed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "north_m_s2"),
    2: .standard(proto: "east_m_s2"),
    3: .standard(proto: "down_m_s2"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.northMS2) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.eastMS2) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.downMS2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.northMS2 != 0 {
      try visitor.visitSingularFloatField(value: self.northMS2, fieldNumber: 1)
    }
    if self.eastMS2 != 0 {
      try visitor.visitSingularFloatField(value: self.eastMS2, fieldNumber: 2)
    }
    if self.downMS2 != 0 {
      try visitor.visitSingularFloatField(value: self.downMS2, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_AccelerationNed, rhs: Mavsdk_Rpc_Offboard_AccelerationNed) -> Bool {
    if lhs.northMS2 != rhs.northMS2 {return false}
    if lhs.eastMS2 != rhs.eastMS2 {return false}
    if lhs.downMS2 != rhs.downMS2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_OffboardResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OffboardResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "result_str"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resultStr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.resultStr.isEmpty {
      try visitor.visitSingularStringField(value: self.resultStr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_Offboard_OffboardResult, rhs: Mavsdk_Rpc_Offboard_OffboardResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.resultStr != rhs.resultStr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_Offboard_OffboardResult.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_UNKNOWN"),
    1: .same(proto: "RESULT_SUCCESS"),
    2: .same(proto: "RESULT_NO_SYSTEM"),
    3: .same(proto: "RESULT_CONNECTION_ERROR"),
    4: .same(proto: "RESULT_BUSY"),
    5: .same(proto: "RESULT_COMMAND_DENIED"),
    6: .same(proto: "RESULT_TIMEOUT"),
    7: .same(proto: "RESULT_NO_SETPOINT_SET"),
  ]
}
